# Security Requirement

### encryption
- Encryption is two-way, in that you can jumble up the information into an
unreadable mess, and then “decrypt” it back into its original form. Hashing is one-way; the original value can never be recovered.
- the data as it flows between the application and the API should be encrypted to protect the privacy of your user.
- any data that gets transmitted should be encrypted
### never trust system input
- Input to your application means literally anything and everything that is not a part of your application or that could have been manipulated outside of your application.
eg: User input on the screen (for instance, entering search phrases into a field),
Information from a database (even the database you designed for your app) 
- anything that comes from outside validate and sanitize
- if we write an application in a non memory safe language do a bounds checking to make sure it doesnt overflow. attackers can buffer overflow (overwrite parts of memory) which not handled would crash our application
- There is no purpose in performing validation of the data after you have used it. It must be the very first thing you do after receiving input into your application.
- When issuing an error message to the screen to reject user input,
if you decide to show the user’s input, be aware that it may be malicious
and therefore potentially cause your program to malfunction. Always
encode the output using HTML encoding
- ndefault administrator group
- we create sub org org admin group
- that obj should be in obj table
- while sharing we will 
- obj table new record
- find out risk preset we are doing (owner
find what all the child arg, create stsme name, group id find., use that )

- Verifying that all third-party components are not known to be vulnerable is a quick-and-easy win in
regard to understanding how secure your application is
- **various statergies to verify known vulnerabilites in third-party components:**
  - use more than 1 tool to check verify. different tools check different stuff so more than 1 tool is preferable
  - regularly scan our code repository  (daily, or at least weekly), as well as scan every time
you release code to production. try building this pipeline into your ci/cd

### Security Headers: Seatbelts for Web Apps
- [security headers](security_headers.md)

### Securing Your Cookies
- [secure cookies](secure_cookies.md)

#### Passwords, Storage, and Other Important Decisions
- password manager+mfa+ different passoword for everyting is the ultimate protection
- What about the passwords of the users of your application? Where should those be stored?
They should be stored in the database (or other centralized place of management such as
an identity provider), in a salted and hashed format.
- user's password hash+ salt and store it in db
(hash is one way so cant decrypt)
- **salting** is
adding a unique, long value to a value before you hash it, in order to increase entropy and
to make it even more difficult for a potential attacker to crack or guess a password.
- we can store our salt in db as well. because the main use of salt is not to use it as a secret.
-  The purpose of a salt is not to make the hash impossible to crack on its own but to make each password hash unique and defend against:
- Rainbow table attacks: Precomputed hash lookup tables.
- Identical password detection: Without salts, users with the same password would have the same hash.
- If the attacker gets both the salt and hash:
  - They still need to brute force the password for each user individually.
  - This is much slower than rainbow table attacks.
- newer techniques like  **work factor** and **peppering** makes it even more harder to crack the password.
- A **work factor** means that you repeat the hashing algorithm X amount of times, with X being the work factor.
- **Peppering**, or a cryptographic pepper, is similar to a salt in that it is added to a password before the password is hashed and it should be generated by a secure random
number generator. However, a pepper is a secret and should not be stored in the database
like a salt, it should be quite long
(minimum 32 characters but preferably 128), and the pepper is unique for each
application, but the same for all users of that application.
- It is possible to both salt and pepper your passwords; however, generally only a salt is required for most systems.
- note that if you rotate the pepper all the passwords are now invalid and the user needs to reset their password with the new pepper
https://haveibeenpwned.com/ useful website to check if your email has been breached
- Never verify if it was the username or password that was incorrect when alerting the user
that they have failed when logging in. Giving this information away allows potential
attackers to harvest usernames (verifying that a user does or does not use your system).
- Security questions are not a modern verification method as most
users select questions for which the answer is publicly available (on social
media, for instance), and thus security questions should be avoided if
possible. example of security questions are whats your favourite color and so on
 ![forget password](../img/5.png)
 - 