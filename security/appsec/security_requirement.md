# Security Requirement

### encryption
- Encryption is two-way, in that you can jumble up the information into an
unreadable mess, and then “decrypt” it back into its original form. Hashing is one-way; the original value can never be recovered.
- the data as it flows between the application and the API should be encrypted to protect the privacy of your user.
- any data that gets transmitted should be encrypted
### never trust system input
- Input to your application means literally anything and everything that is not a part of your application or that could have been manipulated outside of your application.
eg: User input on the screen (for instance, entering search phrases into a field),
Information from a database (even the database you designed for your app) 
- anything that comes from outside validate and sanitize
- if we write an application in a non memory safe language do a bounds checking to make sure it doesnt overflow. attackers can buffer overflow (overwrite parts of memory) which not handled would crash our application
- There is no purpose in performing validation of the data after you have used it. It must be the very first thing you do after receiving input into your application.
- When issuing an error message to the screen to reject user input,
if you decide to show the user’s input, be aware that it may be malicious
and therefore potentially cause your program to malfunction. Always
encode the output using HTML encoding
- ndefault administrator group
- we create sub org org admin group
- that obj should be in obj table
- while sharing we will 
- obj table new record
- find out risk preset we are doing (owner
find what all the child arg, create stsme name, group id find., use that )

- Verifying that all third-party components are not known to be vulnerable is a quick-and-easy win in
regard to understanding how secure your application is
- **various statergies to verify known vulnerabilites in third-party components:**
  - use more than 1 tool to check verify. different tools check different stuff so more than 1 tool is preferable
  - regularly scan our code repository  (daily, or at least weekly), as well as scan every time
you release code to production. try building this pipeline into your ci/cd

### Security Headers: Seatbelts for Web Apps
- [security headers](security_headers.md)

### Securing Your Cookies
- [secure cookies](secure_cookies.md)

### Passwords, Storage, and Other Important Decisions
- password manager+mfa+ different passoword for everyting is the ultimate protection
- What about the passwords of the users of your application? Where should those be stored?
They should be stored in the database (or other centralized place of management such as
an identity provider), in a salted and hashed format.
- user's password hash+ salt and store it in db
(hash is one way so cant decrypt)
- **salting** is
adding a unique, long value to a value before you hash it, in order to increase entropy and
to make it even more difficult for a potential attacker to crack or guess a password.
- we can store our salt in db as well. because the main use of salt is not to use it as a secret.
-  The purpose of a salt is not to make the hash impossible to crack on its own but to make each password hash unique and defend against:
- Rainbow table attacks: Precomputed hash lookup tables.
- Identical password detection: Without salts, users with the same password would have the same hash.
- If the attacker gets both the salt and hash:
  - They still need to brute force the password for each user individually.
  - This is much slower than rainbow table attacks.
- newer techniques like  **work factor** and **peppering** makes it even more harder to crack the password.
- A **work factor** means that you repeat the hashing algorithm X amount of times, with X being the work factor.
- **Peppering**, or a cryptographic pepper, is similar to a salt in that it is added to a password before the password is hashed and it should be generated by a secure random
number generator. However, a pepper is a secret and should not be stored in the database
like a salt, it should be quite long
(minimum 32 characters but preferably 128), and the pepper is unique for each
application, but the same for all users of that application.
- It is possible to both salt and pepper your passwords; however, generally only a salt is required for most systems.
- note that if you rotate the pepper all the passwords are now invalid and the user needs to reset their password with the new pepper
https://haveibeenpwned.com/ useful website to check if your email has been breached
- Never verify if it was the username or password that was incorrect when alerting the user
that they have failed when logging in. Giving this information away allows potential
attackers to harvest usernames (verifying that a user does or does not use your system).
- Security questions are not a modern verification method as most
users select questions for which the answer is publicly available (on social
media, for instance), and thus security questions should be avoided if
possible. example of security questions are whats your favourite color and so on
 ![forget password](../img/5.png)
---
- If your framework offers a security feature, use it. do not write anything on your own and try to use the language's packages as much as possible as they are tested, used by a huge population.
---
### File upload
must read: https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html

- Allowing members of the public (as
opposed to authorized users from within your own organization) to upload files is the
riskiest software functionality that common applications will ever perform.
- When accepting an uploaded file from a user, assume the worst.
- Verify its type and size,
rename the file, do not allow the user to set the path as to where it would be stored, and
store it in a safe place away from the rest of your application and web server. 
- Change the filename to something generated by the application
- Once you
have accepted the file, scan it with at least one tool that can verify if the file is questionable.
- Restrict the files to only specific types that are less
dangerous. For instance, accept JPG, TXT, and PNG, but do not accept PDF or EXE file
types.
- ZIP files are not recommended since they can contain all types of files, and the attack vectors pertaining to them are numerous.
- Malicious file uploads are such a serious and crucial topic that the Canadian government’s
cyber security arm, the Communications Security Establishment of Canada (CSE), created
and open-sourced a free tool to check uploaded files; it is called AssemblyLine
( cyber.gc.ca/en/assemblyline ). It does not share information back to the Canadian
government like many other online tools that are available for no financial cost online.
---
### Error and Logging
https://cheatsheetseries.owasp.org/cheatsheets/Error_Handling_Cheat_Sheet.html
- log all the error
- log all the traces if possible
- never show the actual error in the ui. it doesnt look professional as well as attackers shouldnt get additional information
- never log sensitive information such as passwords. Any combination of information that combined would make personally
identifiable information (PII) should not be logged.
---
### Input Validation and Sanitization
- validate: input is one among the character in allow list
- sanitize: remove unwanted spaces,escape characters, transform the input which we got into whatever we feel more secure
- always vaildate and sanitize at the server. this is because after triggering a js at client side the request can be redirected to a web proxy, changed and then reach the server. so validating at front end is not enougt.
- allways have a allow list not block list. by default block everything and then allow what all are needed
- Your **approved list** should be written with regular
expressions (regex), and anything not matching your expression is not allowed. For
example, if you wanted to allow only a–z and A–Z for a username, you could use this
expression: ^[a-zA-Z]{1,10}$.
---
### Parameterized Queries
- When we use parameterized queries (in SQL they are called stored procedures), we send parameters and the name of the query we want to run to the database, rather than creating a line of code by concatenating user input to create a string and then sending it to the database as a command.
- The difference is that with parameterized queries if an attacker attempts to add their own code to via user input, the application will send it in one of the parameters, and it will not work. This is because the parameters are interpreted by the database as data, never as code, which makes injection attacks nearly impossible.
- When an application concatenates strings of user input and then sends it to the database
directly as a command, this is called “inline SQL,” in the SQL language. Writing inline SQL
creates a potential SQL Injection vulnerability. so always use parameterized sql queries
---
### Requirement Checklist
Requirements Checklist
Below is a checklist that you can use for all your web application projects. All of these
requirements can apply to any web application, and I suggest you include them all as a
minimum, plus add your own that fit your unique business needs.
- [ ] Encrypt all data at rest (while in the database).
- [ ] Encrypt all data in transit (on its way to and from the user, the database, an API, etc.).
- [ ] Trust no one: validate (and sanitize if specialize circumstances apply) all data, even
from your own database.
- [ ] Encode (and escape if need be) all output.
- [ ] Scan all libraries and third-party components for known vulnerabilities before use,
and regularly after use (new vulnerabilities and versions are released all the time).
- [ ] Use all applicable security headers.
- [ ] Use appropriate secure cookie settings.
- [ ] Classify and label all data that your application will store, collect, or create.
- [ ] Hash and salt all user passwords. Make the salt at least 28 characters.
- [ ] Store all application secrets in a secret store.
- [ ] Have all people on your team use password managers and never reuse passwords.
- [ ] Turn on MFA for all important accounts.
- [ ] Do not force password changes on a schedule, but only after a breach or suspicious
activity.
- [ ] Only allow public-facing (internet) sites to be accessible via HTTPS. Redirect from
HTTP to HTTPS. Ideally this would be applied to both internal and external
applications.
- [ ] Ensure you are using the latest version of TLS for encryption (currently 1.3).
- [ ] Never hard code anything. Ever.
- [ ] Never put sensitive information in comments. This includes connection strings and
passwords; those belong in a secret store.
- [ ] Use the security features within your framework; for instance,
cryptography/encryption, session management features, or input sanitization
functions. Never write your own if your framework provides them.
- [ ] Use only the latest version (or the one before) of your framework and keep it up to
date. Technical debt = security debt.
- [ ] If performing a file upload, ensure you are following the advice from OWASP for this
highly risky activity. This includes scanning all uploaded files with a scanner such as
AssemblyLine, available for free from the Communications Security Establishment of
Canada (CSE).
- [ ] Ensure all errors are logged (but do not log sensitive information), and if any security
errors happen, trigger an alert.
- [ ] Ensure all input validation (and sanitization) is performed server side, using an
approved list or accepted list (not a block list) approach.
- [ ] Ensure security testing is performed on your application before being released 
- [ ] Perform threat modeling on your application before being released.
- [ ] Ensure all errors provide generic information to the user, never information from a
stack trace, query fail, or other technically specific information.
- [ ] Define specifics on role-based access in the project requirements.
- [ ] Only use parameterized queries, never inline SQL/NOSQL.
- [ ] Do not pass variables that are of any importance in the URL parameters.
- [ ] Ensure the application enforces the security principle of least privilege, especially in
regard to accessing the database and APIs.
- [ ] Minimize your attack surface whenever possible.
- [ ] Allow users to cut and paste into the password field, which will allow for use of
password managers. Disable password autocomplete features in browsers, to ensure
users do not save their passwords into the browser.
- [ ] Disable caching on pages that contain sensitive information. While the Cache HTTP
header is not technically a security header, it can be used to enforce this requirement.
- [ ] Ensure passwords for your application’s users are long, but not necessarily complex.
The longer the better; encourage use of passphrases.
- [ ] Do not force users to change their passwords after a certain amount of time, unless a
breach is suspected.
- [ ] Verify that new user’s passwords have not previously been in a breach by using a
service designed for such a task.
